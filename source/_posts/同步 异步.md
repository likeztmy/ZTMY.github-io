---
title: 同步与异步
---



#   同步

JS的一大特点是单线程，即每一次只能执行一项任务，后面的任务只能等待前面的任务执行完毕才能继续执行。

同步编程，即是一种典型的请求-响应模型，当请求调用一个函数或方法后，需等待其响应返回，然后执行后续代码。

````
alert('a')

console.log('b')
````

当 alert('a') 未执行完毕之前，console.log('b') 便不会执行



# 异步

由于单线程的特性，就容易出现阻塞的情况。比如说从网络获取文件，访问数据库等等。可以通过异步编程来解决这个问题。

异步编程：请求调用函数或方法后，无需立即等待响应，可以继续执行后面的任务，等到这些响应返回后，可以通过状态，回调函数来通知调用者

````
console.log(1)

setTimeout(() => {
    console.log(2)
}, 1000);

console.log(3)
````



#  原理

JS执行环境中存在两个结构：执行栈和任务队列



执行栈：由执行上下文组成，当函数调用时，创建一个执行上下文，通常称为执行栈帧，并插入执行栈，存储着函数参数和局部变量，当函数执行完毕时，弹出该执行栈帧

任务队列：异步任务的响应返回时，其回调函数将会放到消息队列中



等执行栈内的同步任务执行完毕时，主线程会从任务队列中取出回调函数并插入执行栈中，然后执行回调函数，执行完后退栈。



#  异步操作 setTimeout

````
console.log(1);

setTimeout(() => {
    console.log(2);
}, 2000);

console.log(3);

setTimeout(() => {
    console.log(4)
}, 1000);
````

------



````
console.time('a')

// for循环是一个同步任务，会被放进执行栈内执行
for(var i=0;i<999999;i++){          
	setTimeout(() => {   //内部的setTimeout则是一个异步操作
		console.log(i)   
	}, 0);   // 哪怕时间设置为0 也不会立即执行，需等到同步任务执行完毕后才执行
}           
	
console.timeEnd('a')
````

------



````
console.log(1);

console.log(2);

setTimeout(() => {
    console.log(3);
}, 2000);

setTimeout(() => {
    console.log(10);
}, 1000);

alert("stop"); // 当alert尚未结束时，代码便不会继续读取下去，验证了JS单线程的特点

setTimeout(() => {
    console.log(4);
},5000);

console.log(1111);
````

------



````
console.time('b');

console.log(1);

console.log(2);

setTimeout(() => {
    console.log(4);         
}, 2000);          // 两秒后返回响应，将回调函数放到任务队列

setTimeout(() => {
    console.log(3);
}, 1000);         // 一秒后返回响应，将回调函数放到任务队列

console.time('a');
for(var i=0;i<1666666666;i++);   // 当for循环结束时，才会继续读取下面的代码
console.timeEnd('a');   // for循环花了大概7秒，当下面的1111输出后,执行栈清空
						//立即将任务队列的3、4输出
									
setTimeout(() => {
    console.log(5);
    console.timeEnd('b');
},5000);               //5秒之后才会输出5

console.log(1111);
````





